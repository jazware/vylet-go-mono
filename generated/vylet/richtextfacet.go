// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.

// Lexicon schema: app.vylet.richtext.facet

package vylet

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	lexutil "github.com/bluesky-social/indigo/lex/util"
	cbg "github.com/whyrusleeping/cbor-gen"
)

// RichtextFacet is a "main" in the app.vylet.richtext.facet schema.
//
// Annotation of a sub-string within rich text.
type RichtextFacet struct {
	Features []*RichtextFacet_Features_Elem `json:"features" cborgen:"features"`
	Index    *RichtextFacet_ByteSlice       `json:"index" cborgen:"index"`
}

// RichtextFacet_ByteSlice is a "byteSlice" in the app.vylet.richtext.facet schema.
//
// Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.
type RichtextFacet_ByteSlice struct {
	ByteEnd   int64 `json:"byteEnd" cborgen:"byteEnd"`
	ByteStart int64 `json:"byteStart" cborgen:"byteStart"`
}

type RichtextFacet_Features_Elem struct {
	RichtextFacet_Mention *RichtextFacet_Mention
	RichtextFacet_Link    *RichtextFacet_Link
}

func (t *RichtextFacet_Features_Elem) MarshalJSON() ([]byte, error) {
	if t.RichtextFacet_Mention != nil {
		t.RichtextFacet_Mention.LexiconTypeID = "app.vylet.richtext.facet#mention"
		return json.Marshal(t.RichtextFacet_Mention)
	}
	if t.RichtextFacet_Link != nil {
		t.RichtextFacet_Link.LexiconTypeID = "app.vylet.richtext.facet#link"
		return json.Marshal(t.RichtextFacet_Link)
	}
	return nil, fmt.Errorf("can not marshal empty union as JSON")
}

func (t *RichtextFacet_Features_Elem) UnmarshalJSON(b []byte) error {
	typ, err := lexutil.TypeExtract(b)
	if err != nil {
		return err
	}

	switch typ {
	case "app.vylet.richtext.facet#mention":
		t.RichtextFacet_Mention = new(RichtextFacet_Mention)
		return json.Unmarshal(b, t.RichtextFacet_Mention)
	case "app.vylet.richtext.facet#link":
		t.RichtextFacet_Link = new(RichtextFacet_Link)
		return json.Unmarshal(b, t.RichtextFacet_Link)
	default:
		return nil
	}
}

func (t *RichtextFacet_Features_Elem) MarshalCBOR(w io.Writer) error {

	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if t.RichtextFacet_Mention != nil {
		return t.RichtextFacet_Mention.MarshalCBOR(w)
	}
	if t.RichtextFacet_Link != nil {
		return t.RichtextFacet_Link.MarshalCBOR(w)
	}
	return fmt.Errorf("can not marshal empty union as CBOR")
}

func (t *RichtextFacet_Features_Elem) UnmarshalCBOR(r io.Reader) error {
	typ, b, err := lexutil.CborTypeExtractReader(r)
	if err != nil {
		return err
	}

	switch typ {
	case "app.vylet.richtext.facet#mention":
		t.RichtextFacet_Mention = new(RichtextFacet_Mention)
		return t.RichtextFacet_Mention.UnmarshalCBOR(bytes.NewReader(b))
	case "app.vylet.richtext.facet#link":
		t.RichtextFacet_Link = new(RichtextFacet_Link)
		return t.RichtextFacet_Link.UnmarshalCBOR(bytes.NewReader(b))
	default:
		return nil
	}
}

// RichtextFacet_Link is a "link" in the app.vylet.richtext.facet schema.
//
// Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.
type RichtextFacet_Link struct {
	LexiconTypeID string `json:"$type" cborgen:"$type,const=app.vylet.richtext.facet#link"`
	Uri           string `json:"uri" cborgen:"uri"`
}

// RichtextFacet_Mention is a "mention" in the app.vylet.richtext.facet schema.
//
// Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.
type RichtextFacet_Mention struct {
	LexiconTypeID string `json:"$type" cborgen:"$type,const=app.vylet.richtext.facet#mention"`
	Did           string `json:"did" cborgen:"did"`
}
